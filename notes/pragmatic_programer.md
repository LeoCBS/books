#notes

## be pragmatic is:

* adapt early, adapt fast
* inquisitive, ask always what do you doing, never be in auto-pilot
* thinkig critically
* be realistic
* study various areas and technologies
* always care make well done


## Chatpter One - A Pragmatic Philosophy

### genetal concepts
 * don't live with broken windows
 * stone soap, start simple
 * always remeber the big picture, maintance focus and monitoring changes
 * make quality always one requeremts issue

### building your portifolio

* invest regulary
* diversity, be able  to change
* manage risks - study tecnologies with low and high risk for one low and high return
* always review and rebalance your portifolio

### portifolio goals

* learn at least one new language every year
* read a technical book each quarter
* read nontechnical book too (software are made by people)
* take classea and courses
* participate groups - don't isolate

## Chapter two - A Pragmatic Approach

### orthogonality

* eliminate effect between unrelated things
* facility dev and tests
* promove reuse

### duplication

* difficult maintence (Don't Repeat Yourself)
* don't be lazy same seens more easier
* try make your test as documentation

### flexbility

* encapsulation

### tracer bullet / tracer code

* user get something early
* better feel progress
* user feedback more fast

## Chapter Tree - The Basic Tools

* improve your tools, like vim plugin and shortcuts
* don't comment how code works, but why this code exist, only if must necessary. Comments only trade offs

## Chapter Four - Pragmatic Paranoia

* don't exist perfect software, prevents for mistakes
* Use exception only in excpetion cases, don't make logic with exception. How know when use excpetion? If your program don't run removing catch excpetions, probably you don't use expection correctly

## Chapter Five - Bend, or Break

* less code, less bugs
* make 'shy' code, interact with less people, don't expose
* meta programing - put details out your code, use dynamic configuration, put abstractions in code
 
## chapter Six - While you are coding

* Don't refactor and add functionality at same time
* have good tests
* make smallrefactor, baby steeps
* make tests harnesses
  - a standard way to setup and clean up tests
  - a method for selecting individual or all avaliable tests
  - one way to analyse tests outputs
  - standardize from failure reporting
* test your software, or your user will
* tests is more cultural than technical

## Chapter Seven - Before the project

* work with a User to think like a User
* Abstractions live longer than details - dont programer details
* Use a project detail - avoid developer and user confusion

## Chapter Eight - Pragmatic Projects

* No Broken Windows - quality is a team issue.
* Boiled Frogs - vigilant changes
* improve team communication
* DRY - avoid team duplication work
* Organize around functionality, not job function
* Automate your project
* Test early, test often, test automatically - the earlier a bug is found, the cheapter is to remedy
* Code aint't done'til all the tests run
* Make unit tests, integration tests, valdiation, performance tests
* Testing the tests - sabote your test to verify se test really works
* Find bugs once - always make tests to bugs
* keeping documentation close your code
* Gently exceed your user's expectations - managing expectations
* Don't shirk from responsibility - sign your work - make your work on indicator of quality
